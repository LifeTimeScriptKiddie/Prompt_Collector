={"data":"# Permit.io + Vercel AI SDK + Google AI PoC Project Plan\n\n## 1. Project Overview\n\nThis Proof of Concept (PoC) demonstrates a secure AI system for medical data access with fine-grained authorization using Permit.io, Vercel AI SDK, and Google AI. The system enforces attribute-based access control (ABAC) to protect sensitive medical information while providing personalized AI interactions based on user roles (Doctor or Patient).\n\n## 2. System Architecture\n\n```\n┌──────────────┐       ┌───────────────────┐        ┌─────────────────┐\n│              │       │                   │        │                 │\n│   Frontend   ├──────►│   API Gateway     ├───────►│  AI Pipeline    │\n│   (Next.js)  │       │   (Bun + Hono)    │        │  Orchestration  │\n└──────────────┘       └───────────────────┘        └─────────┬───────┘\n                                                              │\n                                                              ▼\n┌───────────────┐      ┌───────────────────┐        ┌─────────────────┐\n│               │      │                   │        │                 │\n│  Permit.io    │◄─────┤   Vercel AI SDK   │◄───────┤  Google AI      │\n│  Controls     │      │   with RAG        │        │  (Gemini)       │\n└───────┬───────┘      └─────────┬─────────┘        └─────────────────┘\n        │                        │\n        │                        │                  ┌─────────────────┐\n        │                        │                  │                 │\n        │                        └─────────────────►│  Upstash QStash │\n        │                                           │  (Workflows)    │\n        ▼                        ▼                  └─────────────────┘\n┌───────────────┐      ┌───────────────────┐\n│               │      │                   │\n│  Policy Store │      │  Vector Database  │\n│  (OPA/Cloud)  │      │  (GroundX RAG)    │\n└───────────────┘      └───────────────────┘\n```\n\n## 3. Core Components\n\n### 3.1. Frontend Layer\n- Next.js web interface for user authentication and interaction\n- Role-specific UI components for doctors and patients\n- React components for medical data visualization\n- Vercel deployment for frontend and API routes\n\n### 3.2. API Gateway\n- Bun + Hono API routes handling authentication and request routing\n- Integration with Permit.io for initial authorization checks\n- Request validation and sanitization\n- Serverless functions via Vercel\n\n### 3.3. AI Pipeline Orchestration\n- Structured workflows for AI agent configuration\n- Custom integrations for Permit.io\n- Flow management for different medical use cases\n- External hosting or cloud deployment\n\n### 3.4. Vercel AI SDK Components\n- RAG pipeline for medical data retrieval\n- Custom agents with role-based tool access\n- Streaming responses with reasoning for transparency\n\n### 3.5. Permit.io Authorization Layer\n- ABAC policy enforcement for all system interactions\n- Real-time permission checks\n- Attribute-based filtering for medical data\n\n### 3.6. Vector Database (EyeLevel GroundX)\n- Proprietary RAG ingestion pipeline for medical documents\n- Anti-hallucination technology with dynamic chunking\n- Context-aware metadata generation\n- Semantic object creation for higher retrieval accuracy\n- Enterprise-grade security with encryption at rest and in transit\n\n### 3.7. Upstash QStash\n- Asynchronous workflow processing\n- Background job management for long-running tasks\n- Secure scheduling for notification and data processing workflows\n\n## 4. Security Controls Implementation\n\n### 4.1. Prompt Filtering\n- Pre-processing layer using Permit.io to validate prompt intent\n- Prompt classification to determine required permissions\n- Policy-based filtering to block unauthorized queries\n\n### 4.2. Secure Raw Data Retrieval\n- Attribute-based filtering before vector search execution\n- Field-level masking for sensitive information (insurance IDs, full diagnoses)\n- Role-specific data views enforced at retrieval time\n- GroundX's proprietary search engine for improved accuracy over standard vector similarity\n- Result re-ranking based on question relevance\n\n### 4.3. External Access Enforcement\n- Tool usage permission checks before execution\n- Resource-level permissions for appointment scheduling\n- Audit logging of all external actions\n\n### 4.4. Response Enforcement\n- Post-processing of AI responses to remove unauthorized information\n- Content filtering for inappropriate or toxic content\n- Final permission check before delivering response to user\n- Reduction of hallucinations through GroundX's semantic object processing\n\n## 5. Implementation Phases\n\n### Phase 1: Environment Setup and Core Components\n- [ ] Set up Next.js development environment\n- [ ] Configure AI components using Vercel AI SDK\n- [ ] Create EyeLevel GroundX account and obtain API key\n- [ ] Initialize GroundX buckets for medical data storage\n- [ ] Set up Upstash QStash for workflows\n- [ ] Create Permit.io account and initial policies\n- [ ] Establish basic Hono API routes structure\n- [ ] Set up authentication system (Clerk)\n- [ ] Configure Vercel project for deployment\n\n### Phase 2: Authorization Framework\n- [x] Implement Permit.io SDK integration\n- [x] Define ABAC policy model for medical data\n  - Defined condition sets for high clearance records, department-specific access, and patient record ownership\n  - Defined user attributes (department, clearance, specialization, isBlocked)\n  - Defined resource attributes (patientId, sensitivity, department, condition, status)\n  - Implementation requires verification of Permit.io SDK API version for actual deployment\n- [x] Create role definitions for Doctor and Patient\n- [x] Design attribute schema for medical records\n- [x] Implement basic authorization checks\n- [x] Test permission enforcement\n- [ ] Deploy authorization layer to Vercel\n\n### Phase 3: GroundX RAG and Vercel AI SDK Implementation\n- [ ] Upload medical documents to GroundX via API\n- [ ] Build document ingest pipeline for medical data\n- [ ] Implement GroundX-powered search with Vercel AI SDK\n- [ ] Integrate Permit.io checks with RAG workflow\n- [ ] Set up Google AI integration for LLM\n- [ ] Create secure retrieval patterns\n- [ ] Configure Vercel serverless functions for RAG\n\n### Phase 4: AI Pipeline Orchestration\n- [ ] Design custom AI components for Permit.io\n- [ ] Create flow templates for different medical scenarios\n- [ ] Implement security-focused flow patterns\n- [ ] Connect AI pipeline to backend services\n- [ ] Test end-to-end workflows\n- [ ] Configure Vercel Edge functions for optimal performance\n\n### Phase 5: Security Hardening and Testing\n- [ ] Implement comprehensive security testing suite\n- [ ] Conduct red team exercises\n- [ ] Test prompt injection defenses\n- [ ] Verify data isolation between roles\n- [ ] Validate all security controls\n- [ ] Document security architecture\n- [ ] Finalize production deployment on Vercel\n\n## 6. Detailed Technical Tasks\n\n### 6.1. Permit.io Integration\n```typescript\n// Example: Hono middleware for Permit.io integration\nimport { Permit } from 'permitio';\nimport { type Context, type Next } from 'hono';\n\nconst permit = new Permit({\n  pdp: 'https://cloudpdp.permit.io',\n  token: process.env.PERMIT_API_KEY\n});\n\nexport const permitMiddleware = async (\n  c: Context,\n  next: Next\n) => {\n  // Extract user and resource information\n  const user = await getSessionUser(c);\n  const resource = getRequestedResource(c);\n  \n  // Check permissions using Permit.io\n  const allowed = await permit.check({\n    user: user.id,\n    action: c.req.method || 'READ',\n    resource: resource.type,\n    context: { attributes: resource.attributes }\n  });\n  \n  if (!allowed) {\n    return c.json({ error: 'Not authorized' }, 403);\n  }\n  \n  return next();\n};\n```\n\n### 6.2. EyeLevel GroundX RAG Implementation\n```typescript\n// Example: Secure RAG implementation with GroundX and Vercel AI SDK\nimport axios from 'axios';\nimport { streamText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { Permit } from 'permitio';\n\nconst permit = new Permit({\n  pdp: 'https://cloudpdp.permit.io',\n  token: process.env.PERMIT_API_KEY\n});\n\n// Initialize GroundX API client\nconst groundxAPI = axios.create({\n  baseURL: 'https://api.groundx.ai/api/v1',\n  headers: {\n    'X-API-Key': process.env.GROUNDX_API_KEY,\n    'Content-Type': 'application/json'\n  }\n});\n\n/**\n * Upload a document to GroundX\n */\nasync function uploadMedicalDocument(filePath: string, fileName: string, bucketId: number) {\n  const fileData = await fs.readFile(filePath);\n  const base64Data = fileData.toString('base64');\n  \n  const response = await groundxAPI.post('/ingest/documents/local', [{\n    blob: base64Data,\n    metadata: {\n      bucketId: bucketId,\n      fileName: fileName,\n      fileType: getFileType(fileName),\n      // You can add custom metadata attributes to filter on later\n      searchData: {\n        isConfidential: true,\n        department: 'cardiology',\n        lastUpdated: new Date().toISOString()\n      }\n    }\n  }]);\n  \n  return response.data;\n}\n\n/**\n * Perform secure retrieval based on user permissions\n */\nasync function secureRetrieval(user: User, query: string) {\n  // Get user permissions\n  const userAttrs = await permit.getUserAttributes(user.id);\n  \n  // Create filters based on permissions\n  const permissionFilters = createPermissionFilters(userAttrs);\n  \n  // Search for relevant content with GroundX\n  const searchResponse = await groundxAPI.post('/search/content', {\n    query: query,\n    filter: permissionFilters,\n    n: 5, // Number of results to return\n    includeMetadata: true\n  });\n  \n  const { results } = searchResponse.data;\n  \n  // Filter out any sensitive information based on user role\n  const filteredContexts = results.map(result => {\n    if (user.role !== 'doctor' && result.metadata?.isConfidential) {\n      return sanitizeConfidentialContent(result.content);\n    }\n    return result.content;\n  });\n  \n  // Create the context for the LLM\n  const context = filteredContexts.join('\\n\\n');\n  \n  // Generate streaming response using Google AI\n  const gemini = google(\"gemini-2.5-pro-exp-03-25\");\n  \n  const result = streamText({\n    system: `You are a medical assistant. Use ONLY the following context to answer the question: ${context}`,\n    messages: [{ role: \"user\", content: query }],\n    model: gemini,\n    maxSteps: 10,\n  });\n  \n  // Apply post-response filtering\n  // This would be implemented in the API layer when handling the stream\n  \n  return result;\n}\n```\n\n### 6.3. Upstash QStash Workflow\n```typescript\n// Example: Hono API workflow endpoint with Upstash QStash\nimport { serve } from \"@upstash/workflow/nextjs\";\nimport { Permit } from 'permitio';\nimport axios from 'axios';\n\nconst permit = new Permit({\n  pdp: 'https://cloudpdp.permit.io',\n  token: process.env.PERMIT_API_KEY\n});\n\n// GroundX API client\nconst groundxAPI = axios.create({\n  baseURL: 'https://api.groundx.ai/api/v1',\n  headers: {\n    'X-API-Key': process.env.GROUNDX_API_KEY,\n    'Content-Type': 'application/json'\n  }\n});\n\n// Define workflow for processing patient history updates\nexport const { POST } = serve(async (context) => {\n  // Authorization check from headers\n  const authHeader = context.headers.get(\"authorization\");\n  const bearerToken = authHeader?.split(\" \")[1];\n  \n  if (!isValidToken(bearerToken)) {\n    console.error(\"Authentication failed.\");\n    return;\n  }\n  \n  const { patientId, doctorId, recordData } = context.requestPayload;\n  \n  // Check if doctor has permission to update patient records\n  const permissionCheck = await context.run(\"check_permission\", async () => {\n    const allowed = await permit.check({\n      user: doctorId,\n      action: \"update\",\n      resource: \"patient_record\",\n      context: { patientId }\n    });\n    return allowed;\n  });\n  \n  if (!permissionCheck) {\n    return { status: \"error\", message: \"Permission denied\" };\n  }\n  \n  // Process the update in steps\n  const sanitizedData = await context.run(\"sanitize_data\", async () => {\n    // Sanitize and validate incoming data\n    return sanitizePatientData(recordData);\n  });\n  \n  // Upload document to GroundX\n  const documentUpload = await context.run(\"upload_to_groundx\", async () => {\n    // Convert the data to a suitable format\n    const base64Data = Buffer.from(\n      JSON.stringify(sanitizedData)\n    ).toString('base64');\n    \n    // Upload to GroundX\n    const response = await groundxAPI.post('/ingest/documents/local', [{\n      blob: base64Data,\n      metadata: {\n        bucketId: process.env.GROUNDX_BUCKET_ID,\n        fileName: `patient_${patientId}_update_${Date.now()}.json`,\n        fileType: 'json',\n        searchData: {\n          patientId,\n          doctorId,\n          updatedAt: new Date().toISOString()\n        }\n      }\n    }]);\n    \n    return response.data;\n  });\n  \n  await context.run(\"send_notification\", async () => {\n    // Notify relevant parties about the update\n    await sendNotification(patientId, \"Your medical record has been updated\");\n  });\n  \n  return { \n    status: \"success\",\n    documentId: documentUpload[0].id \n  };\n});\n```\n\n### 6.4. Vercel Deployment Configuration\n```json\n// vercel.json\n{\n  \"version\": 2,\n  \"buildCommand\": \"npm run build\",\n  \"devCommand\": \"npm run dev\",\n  \"installCommand\": \"npm install\",\n  \"framework\": \"nextjs\",\n  \"functions\": {\n    \"src/api/workflow/*.ts\": {\n      \"memory\": 1024,\n      \"maxDuration\": 60\n    },\n    \"src/api/chat/*.ts\": {\n      \"memory\": 1024,\n      \"maxDuration\": 30\n    }\n  },\n  \"env\": {\n    \"GOOGLE_GENERATIVE_AI_API_KEY\": \"@google_ai_api_key\",\n    \"PERMIT_API_KEY\": \"@permit_api_key\",\n    \"GROUNDX_API_KEY\": \"@groundx_api_key\",\n    \"GROUNDX_BUCKET_ID\": \"@groundx_bucket_id\",\n    \"QSTASH_URL\": \"@qstash_url\",\n    \"QSTASH_TOKEN\": \"@qstash_token\"\n  }\n}\n```\n\n### 6.5. Custom AI Component\n```typescript\n// Example of a custom AI component connector\nimport axios from 'axios';\nimport { google } from \"@ai-sdk/google\";\nimport { Permit } from 'permitio';\n\nclass PermitSecurityFilter {\n  private permitClient: any;\n  private apiKey: string;\n\n  constructor(config: {\n    permitApiKey: string, \n    googleApiKey: string,\n  }) {\n    this.permitClient = new Permit({\n      pdp: 'https://cloudpdp.permit.io',\n      token: config.permitApiKey\n    });\n    this.apiKey = config.googleApiKey;\n  }\n\n  async checkPromptPermission(userId: string, action: string, resource: string, prompt: string, data: any) {\n    // Check if prompt is allowed using Permit.io\n    const allowed = await this.permitClient.check({\n      user: userId,\n      action: action,\n      resource: resource,\n      context: { prompt, ...data }\n    });\n\n    if (!allowed) {\n      return { \n        status: \"rejected\", \n        reason: \"Unauthorized prompt\" \n      };\n    }\n\n    return { \n      status: \"approved\", \n      filteredPrompt: prompt \n    };\n  }\n\n  async processSecurePrompt(userId: string, prompt: string, context: any) {\n    // First check permissions\n    const permissionCheck = await this.checkPromptPermission(\n      userId,\n      \"query\",\n      \"medical_data\",\n      prompt,\n      context\n    );\n    \n    if (permissionCheck.status === \"rejected\") {\n      return {\n        status: \"error\",\n        message: permissionCheck.reason\n      };\n    }\n    \n    // Initialize the Google AI model\n    const gemini = google(\"gemini-2.5-pro-exp-03-25\");\n    \n    // Process with the AI\n    // In production, this would be a streaming response\n    try {\n      const response = await gemini.invoke([\n        { role: \"system\", content: \"You are a medical assistant. Respond only with verified information.\" },\n        { role: \"user\", content: permissionCheck.filteredPrompt }\n      ]);\n      \n      return {\n        status: \"success\",\n        response: response.content\n      };\n    } catch (error) {\n      console.error(\"AI processing error:\", error);\n      return {\n        status: \"error\",\n        message: \"Failed to process your request\"\n      };\n    }\n  }\n}\n```\n\n## 7. Testing Strategy\n\n### 7.1. Security Testing\n- Prompt injection attacks to bypass filters\n- Role impersonation attempts\n- Attempts to access prohibited data through prompt engineering\n- Testing of data leakage in responses\n- Verification of attribute-based filtering\n- Hallucination detection and mitigation efficacy tests\n\n### 7.2. Functional Testing\n- Role-specific user journeys\n- End-to-end workflow verification using Jest and Cypress\n- Error handling and edge cases\n- Performance under various load conditions\n- Serverless function limits and edge cases in Vercel environment\n- GroundX RAG accuracy and recall comparison tests\n\n### 7.3. Test Cases\n\n| Test Case | Description | Expected Result |\n|-----------|-------------|-----------------|\n| TC-001 | Patient attempts to access another patient's records | Access denied |\n| TC-002 | Patient requests own medical history | Limited access granted |\n| TC-003 | Doctor attempts to access patient records | Access granted with full details |\n| TC-004 | Patient attempts prompt injection | Injection detected and blocked |\n| TC-005 | Doctor books appointment for patient | Operation allowed |\n| TC-006 | Patient attempts to book premium appointment | Operation denied |\n| TC-007 | Response contains unauthorized information | Information filtered before delivery |\n| TC-008 | Vercel function timeout handling | Graceful failure with user notification |\n| TC-009 | Medical document with complex tables and charts | Accurate parsing and retrieval by GroundX |\n| TC-010 | Ambiguous medical query that could cause hallucination | Factual, source-backed response from GroundX RAG |\n\n## 8. Next Steps After PoC\n\n- Production scale Vercel deployment\n- Enhanced monitoring and alerting\n- Expanded policy model for complex medical scenarios\n- Integration with medical information systems\n- User feedback collection and iteration\n- Additional GroundX buckets for specialized medical domains\n"}