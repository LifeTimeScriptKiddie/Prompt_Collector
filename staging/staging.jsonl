={"data":"Awesome‚Äîhere‚Äôs a single, master playbook that covers both phases in one place, with step-by-step tasks you can follow in sequence to ship the chatbot (Phase 1) and then extend it to agent actions (Phase 2). Save it as DETAILED_BUILD_TASKS_WITH_PHASES.md.\n\n\n---\n\n# üß± Detailed Build Tasks (with Phases)\n## AI Onboarding & Workplace Assistant ‚Äî End-to-End Implementation Guide\n**Owner:** Tibbi Labs ‚Ä¢ **Version:** v1.0 ‚Ä¢ **Last Updated:** Oct 2025\n\n> This is your single source of truth to build the product from code-zero to production for **Phase 1 (Chatbot)** and **Phase 2 (Agent Mode)**.  \n> Assumption: AWS account(s), Terraform, VCS, and Bedrock access are already set up.\n\n---\n\n## üìå Roadmap at a Glance\n\n| Phase | Goal | Duration | Exit Criteria |\n|---|---|---|---|\n| **Phase 1 ‚Äì Chatbot (Q&A)** | Google Chat ‚Üí Lambda ‚Üí Bedrock KB grounded answers | ~6 weeks | Accuracy ‚â• 90%, unsafe ‚â§ 0.5%, p95 ‚â§ 2s, UAT pass |\n| **Phase 2 ‚Äì Agent Mode (Actions)** | Bedrock Agent tools ‚Üí Lambda actions (SailPoint/HRMS etc.) | ~8 weeks | Tool success ‚â• 99%, approvals enforced, immutable audit, kill-switch verified |\n\n---\n\n# PHASE 1 ‚Äî Conversational Chatbot (Q&A)\n\n## 1. Google Chat App & Webhook\n\n**Tasks**\n1. Create Chat app (DM-only). Set **App URL** to your API Gateway endpoint.\n2. Enforce signed webhooks; store Google signing secret in **Secrets Manager**.\n3. Whitelist org users (optional) and disable Spaces for now.\n4. Smoke test: send ‚Äúhello‚Äù ‚Üí confirm Lambda is invoked and returns 200.\n\n**Deliverables**\n- Registered Chat app\n- Verified webhook connectivity\n\n---\n\n## 2. Lambda Application (`chat-webhook`) & Routing\n\n**Code Layout**\n\n/lambda ‚îú‚îÄ‚îÄ chat-webhook.py ‚îú‚îÄ‚îÄ requirements.txt ‚îî‚îÄ‚îÄ utils/ ‚îú‚îÄ‚îÄ google_auth.py ‚îú‚îÄ‚îÄ bedrock_client.py ‚îú‚îÄ‚îÄ formatter.py ‚îî‚îÄ‚îÄ logger.py\n\n**Tasks**\n1. Parse webhook payload (userId, message, threadId).  \n2. Verify signature (utils/google_auth.py).  \n3. Fetch minimal user context from DynamoDB (`user_profile`: role, region).  \n4. Build **PII-minimized** prompt; call Bedrock Converse ‚Üí KB.  \n5. Format response for Google Chat (markdown/card + üëç/üëé buttons).  \n6. Log to DynamoDB (`chat_logs`): {user, text, answer, sources, latency, feedback=null}.  \n7. Return 200 with JSON card.\n\n**Acceptance**\n- Round-trip latency ‚â§ 2s (p95), correct formatting in Chat.\n\n---\n\n## 3. Knowledge Base (DocOps) Integration\n\n**S3 + Bedrock KB**\n- S3 bucket (versioned): `kb-company-docs/` (docs, runbooks, policies).\n- Bedrock KB with S3 data source; Titan Embeddings (text) or managed embeddings.\n\n**Sync**\n- GitHub Action ‚Üí `aws s3 sync docs/ s3://kb-company-docs/docs/ --delete`\n- Post-sync: `bedrock start-ingestion-job` (data source IDs via repo secrets).\n\n**Governance**\n- Content review before sync; tag docs with `{dept, region, sensitivity, owner, version}`.\n\n**Acceptance**\n- Queries like ‚ÄúWhat do I do on Day 1?‚Äù return grounded answers w/ references.\n\n---\n\n## 4. Data Layer (DynamoDB)\n\n**Tables**\n- `user_profile` (pk=`USER#{id}`): role, dept, region\n- `chat_logs` (pk=`LOG#{uuid}`): request/response metadata (TTL 90d)\n- `chat_threads` (pk=`THREAD#{chatThreadId}`): optional thread‚Üíuser map (TTL 7d)\n\n**IAM**\n- Lambda policy: least-privilege for GetItem/PutItem on these tables.\n\n---\n\n## 5. Security & Guardrails (Phase 1)\n\n**Controls**\n- Bedrock Guardrails: PII redaction, toxicity, deny lists\n- Prompt hardening: refuse secrets, internal IDs, or tool calls (Phase 1 has no tools)\n- TLS 1.2+, KMS on S3/DDB/Secrets; no secrets in logs\n\n**Kill-Switch (Phase 1)**\n- Feature flag `ENABLE_CHATBOT` (SSM Parameter) checked in handler\n\n---\n\n## 6. Observability & Cost\n\n**Dashboards**\n- Lambda latency/errors/throttles\n- Bedrock token usage & guardrail triggers\n- DDB write throughput\n- Cost per 1k Q&A\n\n**Alarms**\n- p95 latency > 2.5s for 5m\n- Guardrail triggers spike > baseline\n- 5xx from API Gateway > 1%\n\n---\n\n## 7. Testing & UAT\n\n**Test Types**\n- Unit: payload parsing, signature verify, formatter\n- Integration: Chat ‚Üí API GW ‚Üí Lambda ‚Üí Bedrock ‚Üí KB\n- Performance: 100 concurrent messages\n- Safety: prompt injection, PII bait, policy violations\n- UAT: HR/IT scripted flows (‚â•100 Q&A pairs)\n\n**Exit Criteria**\n- Accuracy ‚â• 90%, unsafe ‚â§ 0.5%, p95 ‚â§ 2s, CSAT ‚â• 4.5/5\n\n---\n\n## 8. Launch Runbook (Phase 1)\n\n1. Enable Guardrails & flags; verify dashboard.\n2. Roll out to pilot OU (HR+IT).\n3. Announce bot + quickstart guide.\n4. Monitor 1 week; capture feedback; tune prompt/KB.\n\n---\n\n# PHASE 2 ‚Äî Agent Mode (Actions)\n\n> Build on Phase 1. Keep the same webhook Lambda, add **Agent tools** and **Action Lambdas** behind strict policy gates and audits. MCP is optional and can be added behind a Lambda router.\n\n## 9. Action Surface & Contracts\n\n**Initial Tools (examples)**\n- `submit_access_request(app, role?, justification?)`\n- `get_access_status(requestId)`\n- `list_my_access()`\n\n**OpenAPI (Action Group) ‚Äî Sketch**\n```yaml\nopenapi: 3.0.1\ninfo: { title: Access Tools, version: 1.0.0 }\npaths:\n  /submit_access_request:\n    post:\n      operationId: submit_access_request\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required: [app]\n              properties:\n                app: { type: string, minLength: 2, maxLength: 64 }\n                role: { type: string, maxLength: 64 }\n                justification: { type: string, maxLength: 512 }\n      responses: { \"200\": { description: OK } }\n  /get_access_status:\n    post:\n      operationId: get_access_status\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required: [requestId]\n              properties:\n                requestId: { type: string, pattern: \"^[A-Za-z0-9-]{6,64}$\" }\n      responses: { \"200\": { description: OK } }\n  /list_my_access:\n    post:\n      operationId: list_my_access\n      responses: { \"200\": { description: OK } }\n\nJSON Schema Validation (server-side too)\n\nValidate strings, lengths, enums, and patterns.\n\nReject unknown fields; sanitize justification text.\n\n\n\n---\n\n10. Lambda Tooling & RBAC\n\nLambdas\n\naccess-submit ‚Üí create request in SailPoint/Okta/Jira\n\naccess-status ‚Üí poll status\n\naccess-list ‚Üí list current entitlements\n\n\nServer-Side Enforcement\n\n1. AuthN: map Chat user ‚Üí employeeId (Phase 1 mapping)\n\n\n2. RBAC/ABAC: self-service only unless caller.isManager == true\n\n\n3. Policy checks: per-app allow list, role templates\n\n\n4. Idempotency: Idempotency-Key: {userId}:{app}:{role}\n\n\n5. Audit: write append-only record {who, what, when, inputs(hash), result, correlationId}\n\n\n\nSecrets\n\nOAuth creds in Secrets Manager with rotation policy\n\n\n\n---\n\n11. Orchestration: Bedrock Agent + Action Groups\n\nTasks\n\n1. Create Bedrock Agent with Phase-2 system prompt (ask for missing parameters, confirm risky actions).\n\n\n2. Register Action Group using OpenAPI above, mapping operations to your Lambdas (via API GW).\n\n\n3. Add tool-usage policy in the Agent prompt (never invent data; always return requestId).\n\n\n\nGo/No-Go Gate\n\nTools enabled only in stage first; feature flag per tool (ENABLE_TOOL_SUBMIT, etc.)\n\n\n\n---\n\n12. Optional MCP Bridge (Later)\n\nDesign\n\nKeep current Lambdas; optionally add an MCP client inside a ‚Äúrouter‚Äù Lambda that forwards tool calls to an MCP server for SailPoint, Jira, etc.\n\nThis keeps your Agent ‚Üí Action Group contract stable while letting you standardize integrations.\n\n\n\n---\n\n13. Step Functions (If Multi-Step Approvals)\n\nWhen to use\n\nMulti-stage access (manager ‚Üí app owner ‚Üí provisioning)\n\nLong-running ops (SLA minutes/hours)\n\n\nPattern\n\nAgent calls orchestrate_onboarding tool ‚Üí Step Functions workflow ‚Üí posts status updates to Chat via webhook Lambda.\n\n\n\n---\n\n14. Security Hardening (Phase 2)\n\nAdditions\n\nHuman-in-the-loop confirmations for high-risk actions\n\nKill-switch per tool (SSM Parameter Store)\n\nDeny-by-default tool allow-list\n\nEgress control: only approved API endpoints via VPC endpoints or NAT policy\n\nInput scrubbing: strip prompts attempting to coerce tool behavior\n\nRed-team: run tool abuse & data exfil drills\n\n\n\n---\n\n15. Observability for Actions\n\nDashboards\n\nTool call success rate, error/category (4xx validation vs 5xx upstream)\n\nTime-to-provision per app\n\nPending vs completed requests\n\nAnomaly alerts: spikes in rejected actions, repeated failed attempts\n\n\nTrace IDs\n\nPropagate correlationId from Chat ‚Üí Agent ‚Üí Tool Lambda ‚Üí Upstream system\n\n\n\n---\n\n16. Phase 2 Testing\n\nWhat to test\n\nContract validation (bad inputs rejected)\n\nRBAC (non-manager cannot act for others)\n\nIdempotency (duplicate submit generates one request)\n\nTool misuse (prompt injection to bypass approvals)\n\nLatency budget: tool calls within SLO or gracefully degrade\n\n\nExit Criteria\n\nTool success ‚â• 99%\n\n0 policy bypasses; audit trail complete\n\nManager approval flow verified end-to-end\n\nKill-switch disables tools within 1 minute\n\n\n\n---\n\n17. Rollout Strategy (Phase 2)\n\n1. Dark launch: tools deployed but disabled by flag\n\n\n2. Canary: enable for security/IT admins only\n\n\n3. Pilot: enable for one BU/region\n\n\n4. Org-wide: staged expansion with dashboards/alerts green\n\n\n\n\n---\n\n18. RACI (Phases 1 & 2)\n\nArea\tResponsible\tAccountable\tConsulted\tInformed\n\nChat Lambda\tBackend\tAI Lead\tSecurity\tProduct\nBedrock KB\tAI\tAI Lead\tHR/IT\tProduct\nGuardrails\tSecurity\tCISO\tAI\tAll\nAction Lambdas\tBackend\tPlatform Eng\tSecurity, App Owners\tProduct\nApprovals & RBAC\tSecurity\tCISO\tHR/IT\tAll\nObservability\tDevOps\tPlatform Eng\tSecurity\tAll\nUAT & Launch\tProduct\tProduct\tHR/IT, Security\tAll\n\n\n\n---\n\n19. Deliverables (Checklist)\n\nPhase 1\n\n[ ] Google Chat app (DM-only), signed webhooks\n\n[ ] chat-webhook Lambda + tests\n\n[ ] Bedrock KB (S3 source) + Guardrails\n\n[ ] GitHub‚ÜíS3 sync workflow + KB ingestion\n\n[ ] DDB tables (user_profile, chat_logs, chat_threads)\n\n[ ] CloudWatch dashboards + alarms\n\n[ ] UAT report (accuracy/safety/latency)\n\n\nPhase 2\n\n[ ] OpenAPI spec (tools)\n\n[ ] Action Lambdas (access-submit, access-status, access-list)\n\n[ ] Bedrock Agent + Action Group wiring\n\n[ ] RBAC policy engine + approvals (if needed)\n\n[ ] Immutable audit stream\n\n[ ] Kill-switch flags per tool\n\n[ ] Red-team & tool-abuse report\n\n\n\n---\n\n20. Definition of Done (Per Phase)\n\nPhase 1 DoD\n\n‚úÖ Grounded Q&A with source references\n\n‚úÖ Safety guardrails block unsafe content\n\n‚úÖ Observability and cost dashboards in place\n\n‚úÖ UAT passed; pilot users satisfied (CSAT ‚â• 4.5/5)\n\n\nPhase 2 DoD\n\n‚úÖ Tools operate within RBAC & approvals\n\n‚úÖ Full audit trail & idempotency enforced\n\n‚úÖ Canary + pilot successful; no policy bypasses\n\n‚úÖ Kill-switch validated; playbooks updated\n\n\n\n---\n\n21. Risk Register (Top-5)\n\nRisk\tPhase\tImpact\tMitigation\n\nPrompt injection\t1 & 2\tHigh\tGuardrails, input scrubbing, tests\nHallucinations\t1\tMed\tRAG + sources, accuracy evals\nTool misuse\t2\tHigh\tRBAC, approvals, deny-by-default\nCost spikes\t1 & 2\tMed\tToken trimming, dashboards, budgets\nOutdated KB\t1\tMed\tPre-publish review + frequent sync\n\n\n\n---\n\n22. Appendices\n\nA. Example Prompt Snippets (Phase 1)\n\nSystem: ‚ÄúYou are a safe workplace assistant. Use only provided documents; if unknown, say you don‚Äôt know. Never perform actions.‚Äù\n\nUser template: includes role & region tags only (no raw PII)\n\n\nB. Example Confirmation UX (Phase 2)\n\nBot: ‚ÄúYou‚Äôre requesting VPN access for yourself with role Employee. Proceed?‚Äù\n\nUser: ‚ÄúYes‚Äù\n\nBot: ‚ÄúRequest submitted ‚úÖ REQ-12345. I‚Äôll update you on status.‚Äù\n\n\nC. Rollback Playbook\n\nDisable tools via SSM flag\n\nRevert Agent to Chat-only prompt\n\nFreeze KB ingestion if suspected content issue\n\nRotate affected secrets\n\n\n\n---\n\nThis document is the step-by-step manual to deliver both phases safely and predictably. Follow Phase 1 first; after stabilization, proceed to Phase 2 using the same repo and CI/CD patterns.\n\nIf you want, I can also generate **starter code** for `chat-webhook.py` and the **OpenAPI + JSON Schemas** for Phase-2 tools so your team can start committing right away.Ó®Å0Ó®Ç\n\n"}